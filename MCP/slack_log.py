#!/usr/bin/env python3
"""Slack Log Monitor MCP Server

Exposes tools for tailing and querying the shared Slack message log generated by
Gnosis Slackbot. The log is a newline-delimited JSON file containing metadata
about outgoing messages to channels and direct messages so agents can monitor
bot activity.
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List

from mcp.server.fastmcp import FastMCP

mcp = FastMCP("slack-log")

LOG_PATH = Path(os.environ.get("SLACK_MESSAGE_LOG", "gnosis-slackbot/logs/slack_messages.log"))
DEFAULT_TAIL = 50


def _load_entries() -> List[Dict[str, Any]]:
    if not LOG_PATH.exists():
        return []
    entries: List[Dict[str, Any]] = []
    with LOG_PATH.open("r", encoding="utf-8", errors="replace") as handle:
        for line in handle:
            line = line.strip()
            if not line:
                continue
            try:
                entries.append(json.loads(line))
            except json.JSONDecodeError:
                entries.append({"raw": line})
    return entries


@mcp.tool()
async def slack_log_status() -> Dict[str, Any]:
    """Return information about the Slack message log file."""
    exists = LOG_PATH.exists()
    size = LOG_PATH.stat().st_size if exists else 0
    mtime = datetime.fromtimestamp(LOG_PATH.stat().st_mtime, tz=timezone.utc).isoformat() if exists else None
    return {
        "success": True,
        "log_path": str(LOG_PATH),
        "exists": exists,
        "size_bytes": size,
        "modified": mtime,
    }


@mcp.tool()
async def slack_log_tail(tail: int = DEFAULT_TAIL) -> Dict[str, Any]:
    """Return the most recent log entries."""
    entries = _load_entries()
    tail = max(1, int(tail))
    recent = entries[-tail:]
    return {
        "success": True,
        "count": len(recent),
        "entries": recent,
    }


@mcp.tool()
async def slack_log_since(since_iso: str) -> Dict[str, Any]:
    """Return entries with timestamp greater than the provided ISO 8601 time."""
    try:
        since_dt = datetime.fromisoformat(since_iso)
        if since_dt.tzinfo is None:
            since_dt = since_dt.replace(tzinfo=timezone.utc)
    except ValueError:
        return {"success": False, "error": "Invalid ISO timestamp"}

    entries = _load_entries()
    matched: List[Dict[str, Any]] = []
    for entry in entries:
        ts = entry.get("timestamp")
        if not ts:
            continue
        try:
            entry_dt = datetime.fromisoformat(ts)
        except ValueError:
            continue
        if entry_dt > since_dt:
            matched.append(entry)
    return {
        "success": True,
        "count": len(matched),
        "entries": matched,
    }


if __name__ == "__main__":
    mcp.run(transport="stdio")
